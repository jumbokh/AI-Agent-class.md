

---

## **實驗 1 流程圖指導說明**

### **流程圖解讀與教學重點**

**流程起點 F → 顯示 ATR**
- **核心概念**：ATR (Answer To Reset) 是卡片「通電重置後的回答」
- **教學重點**：
  - ATR 包含卡片製造商、支持協議等底層信息
  - 不同類型卡片有不同 ATR（可用於卡片類型識別）
- **生物聯網意義**：如同設備開機自檢，確認硬體通訊正常

**F → J → 送出 APDU 指令：Get UID**
- **技術解析**：
  - APDU (Application Protocol Data Unit) 是智慧卡應用層協議
  - `FF CA 00 00 00` 是 ACR122U 專用取 UID 指令
- **教學類比**：APDU 就像發送一個「問題封包」，卡片回傳「答案封包」

**關鍵決策點：有找到讀卡機？**
- **故障排查指導**：
  - **Windows**：檢查裝置管理員 → 智慧卡讀取器
  - **Raspberry Pi**：執行 `pcsc_scan` 指令確認驅動狀態
  - **通用檢查**：USB 埠供電是否穩定，讀卡機指示燈狀態

**關鍵決策點：讀 UID 成功？**
- **技術細節**：
  - 成功狀態碼：`90 00`
  - 失敗可能原因：卡片類型不支持、通訊干擾、卡片已移除
- **教學提示**：SW1-SW2 (Status Word) 是除錯的重要依據

### **對應的 Python 程式碼解析**

```python
# 對應流程圖步驟 F：建立連線與取得 ATR
conn = r[0].createConnection()
conn.connect()  # 此步驟隱含了 ATR 獲取
atr = conn.getATR()  # 明確取得 ATR 數據
print("ATR:", toHexString(atr))

# 對應流程圖步驟 J：送出 Get UID APDU
GET_UID = [0xFF, 0xCA, 0x00, 0x00, 0x00]  # APDU 指令定義
data, sw1, sw2 = conn.transmit(GET_UID)   # 送出指令並取得回應

# 對應決策點：讀 UID 成功？
if (sw1, sw2) == (0x90, 0x00):
    print("UID:", toHexString(data))      # 成功：顯示 UID
else:
    print(f"讀 UID 失敗: {sw1:02X} {sw2:02X}")  # 失敗：錯誤處理
```

### **學生常見問題與解答**

**Q: 為什麼有時候 ATR 很長，有時候很短？**
- **解答**：ATR 長度取決於卡片複雜度。簡單的 MIFARE Classic ATR 較短，高安全性的 DESFire 卡片 ATR 較長。

**Q: UID 會重複嗎？在物聯網系統中能直接當作唯一識別嗎？**
- **解答**：理論上 UID 是全球唯一的。但對於高安全性應用，建議結合其他驗證因素，因為某些卡片 UID 可被修改。

**Q: 如果一直顯示「未找到讀卡機」該怎麼辦？**
- **排查步驟**：
  1. 重新插拔 USB，聽是否有偵測音效
  2. 換一個 USB 埠測試（避免供電不足）
  3. 在 Windows 用「裝置管理員」檢查驅動狀態
  4. 在 Raspberry Pi 執行 `sudo systemctl status pcscd`

### **生物聯網應用啟發**

- **設備身份註冊**：利用 UID 為每個物理設備建立數字身份
- **自動化設備識別**：不同類型的感測器使用不同 NFC 標籤，系統通過 UID 自動識別設備類型
- **維護紀錄追蹤**：技術人員用手機讀取設備 NFC 標籤，自動帶出設備資訊與維護歷史

---

這個流程圖很好地呈現了**設備偵測 → 通訊建立 → 數據讀取 → 錯誤處理**的完整流程。
